{
  "posts": [
    {
      "content": "\n<!-- more -->\n",
      "data": {
        "title": "React源码系列7---Hooks",
        "date": "2020-10-06 19:09:12",
        "tags": [],
        "published": false,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "uDD1mzhl4"
    },
    {
      "content": "\n<!-- more -->\n",
      "data": {
        "title": "React源码系列6---状态更新",
        "date": "2020-10-06 19:08:50",
        "tags": [],
        "published": false,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "JXBi3oR4J"
    },
    {
      "content": "\n<!-- more -->\n",
      "data": {
        "title": "React源码系列5---Diff算法",
        "date": "2020-10-06 19:08:29",
        "tags": [],
        "published": false,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "KJBLtvSgx"
    },
    {
      "content": "\n<!-- more -->\n",
      "data": {
        "title": "React源码系列4---commit阶段",
        "date": "2020-10-06 19:07:50",
        "tags": [],
        "published": false,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "SC1B6YCTi"
    },
    {
      "content": "> `Fiber节点`如何被创建？\n> 如何构建一棵`Fiber树`？\n\n<!-- more -->\n\n# render 流程\n`render阶段`开始于`performSyncWorkOnRoot`或者`performConcurrentWorkOnRoot`的方法调用。具体的调用方法取决与是同步还是异步的\n\n> performSyncWorkOnRoot:\n``` javascript\n// performSyncWorkOnRoot同步调用会执行这个方法\nfunction workLoopSync() {\n    while(workInProgress !== null) {\n        // do something\n        performUnitOfWork(workInProgress)\n    }\n}\n```\n``` javascript\n//performConcurrentWorkOnRoot异步调用执行\nfunction workLoopConcurrent() {\n    while(workInProgress !== null && !shouldYield()) {\n        performUnitOfWork(workInProgress)\n    }\n}\n```\n\n* 同步调用和异步调用的区别在于是否调用`shouldYield()`，用于判断当前关键帧是否还有剩余时间；如果当前浏览器帧没有剩余时间的话,`shouldYield`则会中止循环过程，直到浏览器有剩余时间\n* `workInProgress`代表当前已经创建的`workInProgress Fiber`\n* `preformUnitOfWork`方法会创建下一个`Fiber节点`并赋值给`wornInProgress`，并将`workInProgress`与已经创建的`Fiber 节点`连接起来构成`Fiber 树`\n* `Fiber Reconciler`来自于`Stack Reconciler`，通过遍历的方式实现可以中断的递归\n*  [workLoopConcurrent](https://github.com/facebook/react/blob/970fa122d8188bafa600e9b5214833487fbf1092/packages/react-reconciler/src/ReactFiberWorkLoop.new.js#L1599)调用的主要方法就是[performUnitOfWork](https://github.com/facebook/react/blob/970fa122d8188bafa600e9b5214833487fbf1092/packages/react-reconciler/src/ReactFiberWorkLoop.new.js#L1606), `performUnitOfWork`也因此分为两个阶段\n\n## '递'\n* 从`rootFiber`开始，向下，深度优先遍历（栈结构）。为遍历到的每一个`Fiber 节点`调用[beginWork](https://github.com/facebook/react/blob/970fa122d8188bafa600e9b5214833487fbf1092/packages/react-reconciler/src/ReactFiberBeginWork.new.js#L3058)\n* [beginWork](https://github.com/facebook/react/blob/970fa122d8188bafa600e9b5214833487fbf1092/packages/react-reconciler/src/ReactFiberBeginWork.new.js#L3058)会根据传入的`Fiber 节点`创建一个`子Fiber节点`，并将这两个节点链接起来\n* 当遍历到子节点的时候就会进行到`归`的阶段\n## '归'\n* 在这一阶段会调用[completeWork](https://github.com/facebook/react/blob/970fa122d8188bafa600e9b5214833487fbf1092/packages/react-reconciler/src/ReactFiberCompleteWork.new.js#L652)来处理`Fiber节点`\n* 当某个`Fiber节点`执行完`completeWork`，如果存在其`兄弟节点`（`fiber.sibling !== null`）,将会进入`兄弟Fiber`的‘递’阶段\n* **递****归**的过程会交错执行，一直到**归**到最终的`rootFiber`。最后，`render阶段`结束\n\n### Example：\n使用上一节用到的`FunctionComponent`：\n``` javascript\nfunction App() {\n    return (\n        <div>\n            hello\n            <span>React</span>\n        </div>\n    )\n}\n```\n`Fiber树`结构如下：\n![](https://qingwu-aby.github.io//post-images/1602065787452.png)\n`render阶段`执行过程：\n> 1. rootFiber        beginWork\n> 2. App Fiber       beginWork\n> 3. div Fiber        beginWork\n> 4. \"Hello\" Fiber  beginWork\n> 5. \"Hello\" Fiber  completeWork\n> 6. span Fiber     beginWork\n> ~~7. \"React\" Fiber beginWork // React会优化单一文本节点，所以并不会出现~~\n> ~~8. \"React\" Fiber completeWork~~\n> 9. span Fiber     completeWork\n> 10. div Fiber      completeWork\n> 11. App Fiber     completeWork\n> 12. rootFiber     completeWork\n\n**performUnitOfWork递归写法：**\n``` javascript\nfunction performUnitOfWork(fiber)  {\n    // beginWork()\n    if (fiber.child) {\n        performUnitOfWork(fiber.child)\n    }\n    // completeWork\n    if (fiber.sibling) {\n        performUnitOfWork(fiber.sibling)\n    }\n}\n```\n\n# beginWork\n> `beginWork`的工作是传入当前的`fiber 节点`，创建`子Fiber节点`\n``` javascript\nfunction beginWork(\n    current: Fiber | null, // \n    workInProgress: Fiber,\n    renderLanes: Lanes\n): Fiber | null {\n    // do something\n}\n```\n参数：\n* current:  当前组件对应的`Fiber`节点在上一次更新时候的 `Fiber`----`workInProgress.alternate`\n* workInProgress: 当前组件对应的`Fiber节点`\n* renderLanes： 优先级\n\n> 在[双缓存机制](https://qingwu-aby.github.io/post/BlZ715Y5q/#%E5%8F%8C%E7%BC%93%E5%AD%98fiber%E6%A0%91)这一块有提到，组件`mount`的时候，因为是在首屏渲染，此时页面并没有挂载DOM，是不存在当前组件对应的`Fiber 节点`在上次更新时的`Fiber 节点`的，也就是说，在`mount`的时候`current === null`\n\n> **current === null**来判断组件当前是在`mount`还是`update`\n\n基于组件所处的不同状态（`mount`和`update`），`beginWork`可以分为两个部分：\n* `mount`时： 除`fiberRootNode`之外，`current === null`。会根据`fiber.tag`的不同，创建不同的`子Fiber节点`\n* `update`时：如果`current`存在，在满足条件的时候可以复用`current`节点，克隆`current.child`作为`workInProgress.child` ,而不需要新建一个`workInProgress.child`\n\n``` javascript\nfunction beginWork(\n  current: Fiber | null,\n  workInProgress: Fiber,\n  renderLanes: Lanes\n): Fiber | null {\n\n  // update时：如果current存在可能存在优化路径，可以复用current（即上一次更新的Fiber节点）\n  if (current !== null) {\n    // ...省略\n\n    // 复用current\n    return bailoutOnAlreadyFinishedWork(\n      current,\n      workInProgress,\n      renderLanes,\n    );\n  } else {\n    didReceiveUpdate = false;\n  }\n\n  // mount时：根据tag不同，创建不同的子Fiber节点\n  switch (workInProgress.tag) {\n    case IndeterminateComponent: \n      // ...省略\n    case LazyComponent: \n      // ...省略\n    case FunctionComponent: \n      // ...省略\n    case ClassComponent: \n      // ...省略\n    case HostRoot:\n      // ...省略\n    case HostComponent:\n      // ...省略\n    case HostText:\n      // ...省略\n    // ...省略其他类型\n  }\n}\n```\n\n## update\n在`update`的时候可以直接复用前一次更新的`子Fiber`，不需要新建`子Fiber`的情况,即`didReceiveUpdate === false`\n``` javascript\nif (current !== null) {\n    const oldProps = current.memoizedProps;\n    const newProps = workInProgress.pendingProps;\n\n    if (\n      oldProps !== newProps ||\n      hasLegacyContextChanged() ||\n      (__DEV__ ? workInProgress.type !== current.type : false)\n    ) {\n      didReceiveUpdate = true;\n    } else if (!includesSomeLane(renderLanes, updateLanes)) {\n      didReceiveUpdate = false;\n      switch (workInProgress.tag) {\n        // 省略处理\n      }\n      return bailoutOnAlreadyFinishedWork(\n        current,\n        workInProgress,\n        renderLanes,\n      );\n    } else {\n      didReceiveUpdate = false;\n    }\n  } else {\n    didReceiveUpdate = false;\n  }\n```\n1. 当`oldProps === newProps && workInProgress.type === current.type`,也就是在`type`和`props`不变的情况下\n2. `!includesSomeLane(renderLanes, updateLanes)`,当前的`Fiber节点`优先级较低的时候\n\n## mount\n当不满足优化的路径的时候，就会去新建`子Fiber`\n根据`fiber.tag`的不同，进入不同类型的`Fiber`去创建逻辑\n``` javascript\n// mount时：根据tag不同，创建不同的Fiber节点\nswitch (workInProgress.tag) {\n  case IndeterminateComponent: \n    // ...省略\n  case LazyComponent: \n    // ...省略\n  case FunctionComponent: \n    // ...省略\n    return updateFunctionComponent(\n        current,\n        workInProgress,\n        Component,\n        resolvedProps,\n        renderLanes,\n      )\n  case ClassComponent: \n    // ...省略\n    return updateClassComponent(\n        current,\n        workInProgress,\n        Component,\n        resolvedProps,\n        renderLanes,\n      )\n  case HostRoot:\n    // ...省略\n  case HostComponent:\n    return updateHostComponent(current, workInProgress, renderLanes);\n  case HostText:\n    // ...省略\n  case SuspenseComponent:\n     // ...省略 \n  case HostPortal:\n    // ...省略\n  case ForwardRef: \n    // ...省略\n  case Fragment:\n    // ...省略\n  case Mode:\n    // ...省略\n  case Profiler:\n    // ...省略\n  case ContextProvider:\n    // ...省略\n  case ContextConsumer:\n    // ...省略\n  // ...省略其他类型\n}\n```\n> `React`组件类型[TagType](https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactWorkTags.js#L10)\n\n对于常见的组件类型： `FunctionComponent`/`ClassComponent`/`HostComponent`,他们分别调用了`updateFunctionComponent`/`updateClassComponent`/`updateHostComponent`,根据源码找到最终调用了[reconcileChildren](https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiberBeginWork.new.js#L233)\n\n\n## reconcilerChilren\n作为`Reconciler`模块的核心方法：\n* 对于`mount`的组件，他会创建一个新的`子Fiber节点`\n* 对于`update`的组件，他会将当前组件与该组件上次更新时对应时`Fiber 节点`比较（**diff算法**），将比较的结果生成新的`Fiber节点`\n\n``` javascript\nfunction reconcileChildren(\n  current: Fiber | null,\n  workInProgress: Fiber,\n  nextChildren: any,\n  renderLanes: Lanes,\n) {\n  if (current === null) {\n    // If this is a fresh new component that hasn't been rendered yet, we\n    // won't update its child set by applying minimal side-effects. Instead,\n    // we will add them all to the child before it gets rendered. That means\n    // we can optimize this reconciliation pass by not tracking side-effects.\n    workInProgress.child = mountChildFibers(\n      workInProgress,\n      null,\n      nextChildren,\n      renderLanes,\n    );\n  } else {\n    // If the current child is the same as the work in progress, it means that\n    // we haven't yet started any work on these children. Therefore, we use\n    // the clone algorithm to create a copy of all the current children.\n\n    // If we had any progressed work already, that is invalid at this point so\n    // let's throw it out.\n    workInProgress.child = reconcileChildFibers(\n      workInProgress,\n      current.child,\n      nextChildren,\n      renderLanes,\n    );\n  }\n}\n```\n> `mountChildFibers`和`reconcileChildFibers`都调用了同一个方法[ChildReconciler](https://github.com/facebook/react/blob/master/packages/react-reconciler/src/ReactChildFiber.new.js#L1405)，唯一不同的一点是`reconcileChildFibers`会为生成的`Fiber节点`带上`flags`属性，而`mountChildFibers`不会\n> 最终他会生成新的`子Fiber节点`赋值给`workInProgress.child`，作为本次`beginWork`的返回值`return workInProgress.child`，并作为下次`preformUnitOfWork`下次执行的`workInProgress = next`传参\n\n## flags\n* 因为**Renderer阶段**是在内存中进行的，当工作结束之后会通知`Renderer`需要执行的DOM操作；\n* 需要执行的操作类型就是`flags`\n\n> [ReactFiberFlags](https://github.com/facebook/react/blob/master/packages/react-reconciler/src/ReactFiberFlags.js)\n\n## beginWork流程图：\n![](https://qingwu-aby.github.io//post-images/1602074983811.png)\n\n# completeWork\n> 组件执行`beginWork`之后会创建`子Fiber节点`，节点上面可能存在`flags`属性 \n> [completeWork](https://github.com/facebook/react/blob/4ead6b53057ee6c6129a6d2f6e264232130b1fce/packages/react-reconciler/src/ReactFiberCompleteWork.new.js#L800)\n\n和`beginWork`类似，`completeWork`也是根据不同的类型`fiber.tag`处理不同的逻辑\n``` javascript\nfunction completeWork(\n    current: Fiber | null,\n    workInProgress: Fiber,\n    renderLanes: Lanes\n): Fiber | null {\n    const newProps = workInProgress.pendingProps;\n    switch (workInProgress.tag) {\n        case IndeterminateComponent:\n        case LazyComponent:\n        case SimpleMemoComponent:\n        case FunctionComponent:\n        case ForwardRef:\n        case Fragment:\n        case Mode:\n        case Profiler:\n        case ContextConsumer:\n        case MemoComponent:\n        return null;\n        case ClassComponent: {\n        // ...省略\n        return null;\n        }\n        case HostRoot: {\n        // ...省略\n        updateHostContainer(workInProgress);\n        return null;\n        }\n        case HostComponent: {\n        // ...省略\n        return null;\n        }\n    }\n// ...省略\n}\n```\n* 首先看一下与页面`DOM`渲染相关的`Fiber节点`----`HostComponent`\n\n## HostComponet\n\n与上面所说的`beginWork`类似的是，我们同样根据`current === null` 判断当前页面是`mount`还是`update`，同时需要注意的是在`update`的时候`Fiber节点`是否存在对应的`DOM节点`，即`workInProgress.stateNode !== null`\n\n``` javascript\ncase HostComponent: {\n    popHostContext(workInProgress)\n    const rootContainerInstance = getRootHostContainer()\n    const type = workInPropgress.type\n\n    if (current !== null && workInProgress.stateNode !== null) {\n        // update,---> ## update\n    } else {\n        // mount\n    }\n    return null\n}\n```\n\n## update\n\n当`update`的时候，`Fiber节点`已经存在对应的`DOM节点`，不需要生成`DOM`；主要工作在于处理`props`: **事件回调**，**style**， **children**...\n\n``` javascript\nif (current !== null && workInProgress.stateNode !== null) {\n    //update\n    updateHostComponent(\n        current,\n        workInProgress,\n        type,\n        newProps,\n        rootContainerInstance\n    )\n}\n```\n> [updateHostComponent](https://github.com/facebook/react/blob/master/packages/react-reconciler/src/ReactFiberCompleteWork.new.js#L242)方法定义\n\n``` javascript\n const updatePayload = prepareUpdate(\n      instance,\n      type,\n      oldProps,\n      newProps,\n      rootContainerInstance,\n      currentHostContext,\n    );\n    // TODO: Type this specific to this type of component.\n    workInProgress.updateQueue = (updatePayload: any);\n```\n在[updateHostComponent](https://github.com/facebook/react/blob/master/packages/react-reconciler/src/ReactFiberCompleteWork.new.js#L242)内部`props`处理完了之后，会赋值给`workInProgress.updateQueue = (updatePayload: any)`,并在最终`commit阶段`进行渲染\n\n## mount\n\n在`mount`的时候主要逻辑：\n* 为`Fiber节点`生成对应的`DOM节点`\n* 将`子节点`插入生成的`DOM节点`中\n* 处理`props`\n\n``` javascript\n\nconst currentHostContext = getHostContext();\n// 为fiber创建对应DOM节点\nconst instance = createInstance(\n    type,\n    newProps,\n    rootContainerInstance,\n    currentHostContext,\n    workInProgress,\n  );\n// 将子孙DOM节点插入刚生成的DOM节点中\nappendAllChildren(instance, workInProgress, false, false);\n// DOM节点赋值给fiber.stateNode\nworkInProgress.stateNode = instance;\n\n// 与update逻辑中的updateHostComponent类似的处理props的过程\nif (\n  finalizeInitialChildren(\n    instance,\n    type,\n    newProps,\n    rootContainerInstance,\n    currentHostContext,\n  )\n) {\n  markUpdate(workInProgress);\n}\n```\n\n> `mount`时只会在`rootFiber`存在`PlaceMent``flags`；\n> 因为`completeWork`是处于`归`阶段调用的方法，每次调用`appendAllChildren`的时候，都会将已经生成的`子DOM节点`插入到当前的已经生成的`DOM节点下`。当**归**阶段执行到`rootFiber`时，我们已经可以得到一个构建好的`DOM树`\n\n# 流程结束\n\n至此，render阶段全部工作完成。在performSyncWorkOnRoot函数中fiberRootNode被传递给commitRoot方法，开启commit阶段工作流程。[commitRoot](https://github.com/facebook/react/blob/master/packages/react-reconciler/src/ReactFiberWorkLoop.new.js#L1049)\n``` javascript\ncommitRoot(root)\n```\n# complete 流程图\n\n![](https://qingwu-aby.github.io//post-images/1602148486898.png)\n\n\n\n\n\n",
      "data": {
        "title": "React源码系列3---Render阶段",
        "date": "2020-10-06 18:50:58",
        "tags": [],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "> `Fiber节点`如何被创建？\n> 如何构建一棵`Fiber树`？",
      "fileName": "85DIMWyxi"
    },
    {
      "content": "> React Fiber架构\n**Scheduler-Reconciler-Renderer**\n\n<!-- more -->\n\n# Fiber 架构\n## 代数效应\n> `代数效应`用于将`副作用`从`函数`中分离，保持函数的纯粹性\n\n### 代数效应在React中的应用\n> `For example`--->`Hooks`;对于`useState`,`useReducer`,`useRef`，我们不需要关注`FunctionComponent`的`state`在`Hook`中如何保存\n``` javascript\nfunction App() {\n    const [count, setCount] = useState(0)\n    const handleClick = () => {\n        setCount(count => count + 1)\n    }\n    return (\n        <button onClick={handleClick}>{count}</button>\n    )\n}\n```\n\n### 代数效应与Generator\n> 从`React15`到`React16`**Reconciler**的架构从`同步更新`变更到了`可中断的异步更新`\n> `异步可中断更新`：更新的执行过程中随时可能会被中断（浏览器时间分片用尽或者更高优先级的任务插队），当可以继续执行的时候恢复之前执行的中间状态\n> `Generator`实现异步可中断更新\n### 代数效应与Fiber\n\n> `React Fiber`: 类似于`协程`\n> - `React`内部的一套状态更新机制。支持不同的`优先级`，可以更新和恢复，并且在恢复之后可以服用之前的`中间状态`\n> - 其中每个任务更新单元为`React Element`对应的`Fiber`节点---**虚拟DOM**\n\n## Fiber的实现原理\n> `Fiber`之前的架构导致的问题： `Reconciler`采用递归的方式去更新虚拟DOM，递归过程是不能中断的。如果组件树的层级很深，递归就会占用线程大量的时间和资源，造成页面卡顿\n> `React16`将`递归的无法中断的更新`重构为`异步的可中断更新`，由此产生了新的`Fiber`架构\n\n### What is Fiber\n> - 作为架构来说，`React15`的`Reconciler`采用递归的方式去执行，数据保存在**递归调用栈**中---`Stack Reconciler`。`React16`的`Reconciler`基于`Fiber节点`----`Fiber Reconciler`\n>  - 作为静态数据结构来说，每一个`Fiber节点`对应一个`React Element`，保存了该组件的类型（class\\FunctionComponent\\HostComponent）、对应的DOM节点信息\n>  - 作为动态的工作单元来说，每一个`Fiber节点`保存了本次更新中该组件改变的状态、要执行的工作等（增加\\删除\\更新...）\n\n### Fiber的结构\n> [Fiber节点定义](https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactFiber.new.js#L117)\n<!-- more -->\n\n``` javascript\nfunction FiberNode (\n    tag: WorkTag,\n    pendingProps: mixed,\n    key: null | string,\n    mode: TypeOfMode\n) {\n    // 作为静态数据结构的属性\n    this.tag = tag;\n    this.key = key;\n    this.elementType = null;\n    this.type = null;\n    this.statNode = null;\n\n    // 用于链接其他Fiber节点形成Fiber树\n    this.return = null;\n    this.child = null;\n    this.sibling = null;\n    this.index = 0;\n\n    this.ref = null;\n\n    // 作为动态的动作单元的属性\n    this.penfingProps = pendingProps;\n    this.memoizedProps = null;\n    this.updateQuene = null;\n    this.memoizedState = null;\n    this.dependencies = null;\n\n    this.mode = mode;\n\n    this.effectTag = NoEffect;\n    this.nextEffect = null;\n\n    this.firstEffect = null;\n    this.lastEffect = null;\n\n    //调度优先级\n    this.lanes = NoLanes;\n    this.childLanes = NoLanes;\n\n    //指向该fiber在另一次更新时候对应的fiber，双缓存的时候链接current Fiber和workInProgress Fiber\n    this.alternate = null;\n<!-- more -->\n\n<!-- more -->\n\n}\n```\n\n### Fiber作为架构\n> 每一个Fiber节点都有对应的`React  Element`,多个`Fiber节点`应该如何链接成树？\n``` javascript\n// 指向父级Fiber节点； 指节点执行完completeWork之后会返回的下一个节点\nthis.return = null;\n// 指向子Fiber节点\nthis.child = null;\n// 指向右边第一个兄弟节点\nthis.sibling = null;\n```\n如下示例：\n``` javascript\nfunction App() {\n    return (\n        <div>\n            hello\n            <span>React</span>\n        </div>\n    )\n}\n```\n对应的`Fiber树`结构：\n![](https://qingwu-aby.github.io//post-images/1602065772823.png)\n>> `return`指节点执行完`completeWork`之后会返回的下一个节点，子节点及其兄弟节点在完成工作之后会返回其父级节点\n\n### 作为静态的数据结构\n`Fiber`作为静态的数据结构，保存了组件的相关信息：\n``` javascript\n// Fiber对应的组件类型，FunctionComponent/Class/HostComponent...\nthis.tag = tag;\n// key属性\nthis.key = key;\n// 当FunctionComponent使用React.memo包裹的时候type不一样\nthis.elemenType = null;\n// 对于FunctionComponent,指函数本身\n// 对于ClassComponent，指class,\n// 对于HostComponent，指DOM节点tagName\nthis.type = null;\n// Fiber反应的真实DOM节点\nthis.stateNode = null; \n```\n### 作为动态的工作单元\n作为动态的工作单元，`Fiber`保存了本次更新相关的信息\n``` javascript\n// 保存本次更新造成的状态改变相关信息\nthis.pendingProps = pendingProps;\nthis.memoizedProps = null;\nthis.updateQueue = null;\nthis.memoizedState = null;\nthis.dependencies = null;\n\nthis.mode = mode;\n\n// 保存本次更新会造成的DOM操作\nthis.effectTag = NoEffect;\nthis.nextEffect = null;\n\nthis.firstEffect = null;\nthis.lastEffect = null;\n```\n\n## Fiber的工作原理\n- `Fiber节点`构成`Fiber树`，`Fiber树`对应`DOM树`\n- 直接在内存中构建并直接替换的技术--->双缓存\n- 双缓存技术----`Fiber树`的构建与替换-->对应着`DOM树`的构建与更新\n### 双缓存Fiber树\n在`React`中最多存在**两棵**`Fiber树`。\n- 当前屏幕上显示内容对应的`Fiber树`称为`Current Fiber树`\n- 正在内存中构建的`Fiber树`，称为`workInProgress Fiber树`\n\n`current Fiber树`中的`Fiber节点`称为`current Fiber`；同理`workInProgress Fiber树`中的`Fiber节点`称为`workInProgress Fiber`，他们之间通过上文讲过的`alternate`链接\n\n``` javascript\ncurrentFiber.alternate === workInProgressFiber;\nworkInProgress.alternate === currentFiber;\n```\n- `React`应用的根节点通过`current`指针在不同的`Fiber树`的`rootFiber`之间切换来实现`Fiber树`的切换。\n- 当`workInProgress Fiber树`构建完成交付给`Renderer`渲染页面上之后，应用的根节点的`current`指针指向`workInProgress Fiber树`，此时`workInProgress Fiber树`变更为`current Fiber 树`\n- 每一次的状态更新都会产生新的`workInProgress Fiber树`，通过`current`与`workInProgress`的交换，完成DOM更新。以下为`mount`和`update`时的构建与替换流程\n\n### mount\nexample：\n``` javascript\nfunction App() {\n    const [count, setCount] = useState(0)\n    return (\n        <p onClick={() => setCount(count + 1)}>{count}</p>\n    )\n}\nReactDOM.render(<App />, document.getElementById('root'))\n``` \n1. * 首次执行`ReactDOM.render`会创建`fiberRootNode`（源码里面的`fiberRoot`）和`rootFiber`；其中`fiberNodeRoot`是整个应用根节点，`rootFiber`是`<App />`所在组件树的根节点\n    * 区分`fiberRootNode`和`rootFiber`的原因在与，在应用中可以多次调用`ReactDOM.render`渲染不同的组件树，他们拥有不同的`rootFiber`。但是整个应用的根节点只有一个，就是`fiberRootNode`\n    * `fiberRootNode`的`current`会指向当前页面上已经渲染内容对应的`Fiber树`----`current Fiber 树`\n![](https://qingwu-aby.github.io//post-images/1601972147860.png)\n``` javascript\nfiberRootNode.current = rootFiber\n```\n\n> 由于是首屏渲染，此时页面还没有挂载任何`DOM`，所以`fiberRootNode.current`指向的`rootFiber`没有任何`子Fiber节点`（`current Fiber树为空`）\n\n2. * 进入`render阶段`，根据组件返回的`JSX`在内存中依次创建`Fiber` 节点并链接在一起构建`Fiber树`，这个时候被称为`workInProgress Fiber树`\n   * 在构建`workInProgress Fiber树`时会尝试复用`current Fiber树`中已经存在的`Fiber 节点`内的属性，在**首屏渲染**的时候只有`rootFiber`存在对应的`current Fiber`（`rootFiber.alternate`）\n\nFiber render阶段：\n![](https://qingwu-aby.github.io//post-images/1601979189296.png)\n\n3. * 上图所示的已经构建完成的`workInProgress Fiber树`在`commit阶段`渲染到页面\n   * 此时页面中DOM被重新渲染,`current`指针指向`workInProgress Fiber树`，使其成为`Current Fiber树`\n  ![](https://qingwu-aby.github.io//post-images/1601979443787.png)\n\n### update\n\n1. * 我们点击`p标签`的时候会触发`onclick`。改变状态值，这个操作会开启一次新的`render阶段`并构建一个新的`workInProgress Fiber树`\n图示如下：\n![](https://qingwu-aby.github.io//post-images/1601979728492.png)\n   * 与`mount`的时候一样，`workInProgress Fiber`的创建可以复用`current fiber树`对应的节点数据\n  **这个决定是否使用的过程就是diff算法**\n\n2. * `workInProgress Fiber 树`在`render阶段`完成构建之后进入`commit阶段`渲染到页面上。在渲染完毕之后，当前的`workInProgress Fiber树`变更为`current Fiber树`\n\n![](https://qingwu-aby.github.io//post-images/1601979993153.png)\n\n> `Fiber树`的构建和替换的过程会伴随着`DOM`的更新\n\n# React的Scheduler-Reconciler-Renderer架构体系\n * `Reconciler`工作的阶段被称作`render`阶段。因为在该阶段调用组件的`render`方法\n * `Renderer`阶段被称为`commit阶段`《类似于`git commit`》，`commit阶段`会把`render`提交的信息渲染在页面上\n * `render`与`commit`阶段的统称为`work`，也就是`React`的工作流程，如果任务处于`Scheduler`内部进行调度，不是`work`\n\n# JSX与Fiber节点\n* `JSX`是一种描述当前组件数据类型的数据结构，不包含**schedule**、**reconcile**、**render**所需要的相关信息\n    * 组件在更新中的`优先级`\n    * 组件的`state`\n    * 组件被打上用于**Reconciler**的标记\n* 在组件`mount`的时候，`Reconciler`根据 `JSX`描述的组件内容生成对应的`Fiber节点`\n* 在组件`update`的时候，`Reconciler`将`JSX`与`Fiber节点`保存的数据进行对比，生成组件对应的`Fiber节点`，并根据对应的结果给`Fiber节点`打上标记\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
      "data": {
        "title": "React源码系列2----React Fiber",
        "date": "2020-10-02 18:15:29",
        "tags": [],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "> React Fiber架构\n**Scheduler-Reconciler-Renderer**",
      "fileName": "BlZ715Y5q"
    },
    {
      "content": "<!-- START-SECTION:setup-toc-->\n# 链表和数组\n\n##  区别：\n> 1. 数组： 可以连续存储，通过数组的索引可以很快的查找数据；连续存储的问题点也在于此，需要在创建的时候一次性的分配所有数据所需要的内存，数组如果需要扩容，则需要重新分配一块更大的空间，将原有数组复制过去，这个复制操作时间复杂度是O(n)，同理，如果在数组中插入数据或者删除数据的时候则需要将插入点（删除点）之后的所有数组索引移动，用于保持当前数组的连续性，因为要进行遍历则时间复杂度为O（n）。\n> 2. 链表：数据的存储结构是不连续，是依赖于指针指向下一个元素的位置，所以链表的扩容问题不存在；只需要知道某元素的前驱节点和后驱节点就可以进行删除和更新操作，时间复杂度为O(1),因为链表的存储结构不连续，导致了链表不能够像数组一样拥有随机访问的特征，所以也就无法通过索引找到对应的元素；同时与数组相比，链表需要额外的空间去存储一个元素的前后节点。\n\n##  数据结构的基本操作\n\n**增删改查**\n> 数据结构是为了更高效的增删改查而存在的\n> 访问和遍历的方式一共两种：线性和非线性\n> 1. 线性：以`for/while`迭代为主\n``` javascript\n    // 数组遍历\n    const arr = []\n    for(let i = 0; i< arr.length ; i++) {\n        // 数组迭代\n    }\n ```\n> 2. 非线性：递归\n",
      "data": {
        "title": "基本数据结构",
        "date": "2020-09-26 15:37:14",
        "tags": [],
        "published": false,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "8M8V_muR3"
    },
    {
      "content": "\nReact不同版本源码的差异\n<!-- more -->\n\n**React的理念**\n> 速度快，响应自然\n\n# React的架构\n## React15\n\n- Reconciler——找出发生变化的组件\n- Renderer——渲染发生变化的组件\n### Reconciler\n\n> `React`中会通过`this.setState`,`this.forceUpdate`,`ReactDom.render`等方法更新组件\n> - 调用函数组件、class组件的`render`方法，将返回的JSX转换为虚拟DOM\n> - 将虚拟DOM与上次的进行比较\n> - 找出本次发生更新的虚拟DOM\n> - 通知**Renderer**将变化的虚拟DOM渲染到页面上\n### Renderer\n\n> 每次更新发生的时候，**Renderer**接收到**Reconciler**的通知，将变化的组件渲染到当前的宿主环境\n### React15的缺陷\n\n**无法支持同步更新**\n**递归的去更新会导致某写情况下页面的渲染结果不一致**\n\n> 在`Reconciler`中，`update`的组件会调用`updateComponent`,`mount`的组件会调用`mountComponent`，这两个方法都是递归执行的\n>\n> JS是一门单线程的语言，他的`GUI渲染线程`和`JS主线程`是互斥的，也就是说在页面执行我们的js代码的时候是不能够去渲染和绘制页面的，在我们渲染每一帧页面的时候：\n```\nJS代码执行-------样式布局-------样式绘制\n```\n> - 当JS代码执行的时间超过每一帧的时长的时候，页面上就无法反映出本次渲染的结果\n> - 同时，对于`React`来说，因为递归执行的原因，所以会导致页面一旦开始更新就无法终止；如果我们页面的层级变得很深，就会导致递归更新的时间过长，页面无法渲染\n> - **Scheduler**和**Reconciler**是交替渲染的\n\n## React16\n> `React16`的架构有三层：\n> - Schduler（调度器）——调度人物的优先级，高优先级任务优先进入**Reconciler**\n> - Reconciler（协调器）——找出变化的组件（`Fiber`架构？）\n> - Renderer（渲染器）——将变化的组件渲染到页面上\n>> 其中**Scheduler**和**Reconciler**是平台无关的\n\n### Scheduler（调度器）\n> 我们以浏览器每一帧是否有剩余时间作为任务中断的标准，需要有一种机制通知我们浏览器什么时候有剩余时间----`requestIdleCallback`\n> `React`实现了`requestIdleCallback`的polyfill---**Scheduler**；除了在浏览器空闲时间触发回调，还提供了多种调度优先级\n\n### Reconciler（协调器）\n> 在`React15`中，**Reconciler**是递归处理虚拟DOM的\n> `React16`中更新的过程从递归变成了可以终中断的循环过程，每一次循环都回去调用`shouleYield`判断当前是否有剩余时间\n``` javascript\nfunction workLoopConcurrent() {\n    while(workInProgress !== null && !shouldYield()) {\n        workInProgress = performUnitOfWork(workInProgress)\n    }\n}\n```\n> 关于`React15`中的因为一些特殊原因导致中断更新的时候DOM渲染不完全的问题\n>\n> 在`React16`中，**Reconciler**和**Renderer**不是交替工作的。当**Scheduler**将任务交给**Reconciler**的时候，**Reconciler**会为变化的虚拟DOM搭上增/删/更新的标记\n>> 其他的[标记](https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactSideEffectTags.js)\n> 因为整个**Scheduler**和**Reconciler**的过程都是在内存中进行的。只有当组件都完成在**Reconciler**的工作，才会统一交给**Renderer**\n\n### Renderer（渲染器）\n\n> **Renderer**根据**Reconciler**为虚拟DOM的打上的标记，同步执行对应的DOM操作。\n> **Scheduler**和**Reconciler**中的步骤随时会因为，有更高优先级的任务进来，或者当前帧没有剩余时间而中断。因为 **Scheduler**和**Reconciler**中的工作都是在内存中进行的，并不会更新页面，所以即使这个里面出现反复中断，也不会影响用户的体验（看见部分DOM更新不完全）\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
      "data": {
        "title": "React源码系列1---React15和16的差别",
        "date": "2020-09-23 20:16:23",
        "tags": [],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "\nReact不同版本源码的差异",
      "fileName": "E0UjUKnBP"
    },
    {
      "content": "\n[toc]\n\n<!-- 迫于无奈特意开了这个系列，遵照网上的一些资源加上自己的理解去深入的学习一下React -->\n\n\n----\n\n# 准备工作\n\n1. 我们需要知道什么是虚拟DOM\n2. 如何生成虚拟DOM\n\n## 什么是虚拟DOM\n> 我们都知道浏览器渲染一个页面是首先生成一棵DOM树，然后再渲染`css`,`js`；据此可知道，我们的虚拟DOM树实际上就是一个个具有固定格式的`js`对象\n> ``` javascript\n>  const treeObj = {\n>   tag: 'div',\n>   attrs: {\n>       'className': 'test-class_title'\n>   },\n>   children: [\n>       {\n>           key: 'p',\n>           attrs: {\n>               className: 'test-class-children_title'\n>           }\n>           children: [\n>               ...\n>           ]\n>       }\n>   ]\n> }\n> ```\n> 如上所述，通过这个一个简单的对象就能渲染出一个真实的DOM，其中`p`标签实际上是`div`的一个子元素，真实节点描述如下：\n> ``` javascript\n> <div className='test-class_title'>\n>   <p className='test-class-children_title'></p>\n> </div>\n> ```\n\n## 如何生成一棵`DOM`树\n> 这一切的基准点都是从`Babel`的\n>  1. 首先需要把代码抽象成一棵抽象语法树（`AST`）\n>  2. 然后去解析\n>  3. 生成浏览器可识别的代码（`js`） \n**这里以`React`代码举一个例子:**\n> ``` javascript\n> class App extends React.Component {\n>   render() {\n>       return <div>div</div>\n>   }\n> }\n> ```\n> 这段代码最终会被编译成：[Babel](https://www.babeljs.cn/repl#?browsers=&build=&builtIns=false&spec=false&loose=false&code_lz=MYGwhgzhAECCAO9oFMAeAXZA7AJjASsmMOgHQDCA9gLbyVbboDeAUAJABO2OyHAFAEpW0EdC7oArhyzQAPDgCWANwB8ipbID06lS1HQAviyMsgA&debug=false&forceAllTransforms=false&shippedProposals=false&circleciRepo=&evaluate=false&fileSize=false&timeTravel=false&sourceType=module&lineWrap=true&presets=es2015%2Creact&prettier=false&targets=&version=7.5.5&externalPlugins=)\n> ``` javascript\n> ...\n> _createClass(App, [{\n>   key: 'render',\n>   value: function render() {\n>       return React.createElement('div', null, 'div')\n>   }\n> }])\n> ... // 省略\n> ```\n> 从这里我们可以看出来`return <div>div</div>`经过解析以及`babel`的转换之后变成了`return React.createElement('div', null, 'div')`\n> \n### 如何转换\n> 由上文可知，代码最终被转换为`React.createElement()`这种方式，可以在全局挂载一个`React`对象，将`createElement`挂载在`React`下面\n> ``` javascript\n> const React = {}\n> React.createElement = function(tag, attrs, ...children) {\n>   return {\n>       tag,\n>       attrs,\n>       children\n>   }\n> }\n> export default React\n> ```\n\n",
      "data": {
        "title": "秋天里的React--1",
        "date": "2020-09-20 16:27:10",
        "tags": [
          "React"
        ],
        "published": false,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "0rtsFvZCm"
    },
    {
      "content": "\n<!-- more -->\n1. Js基础\n    1. `Promise`\n    2. `setTimeout`和`setInterval`\n    3. `eventloop`\n    4. `prototype`\n    5. `proxy`\n    6. ES静态分析\n    7. 垃圾回收\n    8. `call，apply，bind`\n    9. 闭包与内存泄漏\n    10. 浏览器GC\n    11. 节流与防抖\n    12. `requestIdleCallback`\n    13. 排序`sort`方法的应用，以及是否对字符串排序的原理\n    14. 深浅拷贝\n    15. 数组去重\n2. React 源码分析\n    1. 虚拟dom\n    2. `hooks`\n    3. `fiber` 和 `requestIdleCallback`\n3. redux\n    1. `compose`实现逻辑\n    2. `saga`\n    3. `normlize`\n    4. 不可变数据类型immutable\n4. `NodeJS`\n    1. 事件系统（eventbus）\n    2. 缓冲队列\n5. 数据结构\n    1. 基础数据结构（数组与链表）\n    2. 树，图\n6. 算法\n    1. 基础排序\n    2. 动态规划\n    3. 树相关算法\n7. 前端性能调优\n    1. `FCP/FMP/FR`\n8. 前端安全问题\n    1. `csrf` 跨站脚本攻击\n9.  前端错误监控与上报\n    1.  sentry\n    2.  kibana\n    3.  异常的捕获及其区别\n10. 计算机网络\n    1. TCP/IP\n    2. HTTP\n    3. HTTPS\n11. 浏览器相关\n    1.  渲染机制\n    2.  设计模式\n12. 操作系统相关\n    1.  进程和线程\n13. `nginx`\n    1.  负载均衡\n    2.  反向代理\n14. 前端项目打包与脚手架以及工具类\n    1.  `webpack`\n    2.  `babel`\n\n** 数据结构与算法**\n**JS基础**\n**React+Redux**\n",
      "data": {
        "title": "学习方案",
        "date": "2020-08-09 14:44:25",
        "tags": [
          "JS基础",
          "算法和数据结构",
          "todo"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "tui-jin-jie-zou"
    },
    {
      "content": "> 回溯算法实际上是一个决策树的遍历过程\n\n    * 路径： 即已经做出的选择\n    * 选择列表：当前可以做出的决策\n    * 结束条件： 到达树底的时候，无法作出选择的条件\n\n```\nresult = []\nconst backtrack(路径, 选择列表) {\n    if 满足结束条件:\n        result.add(路径)\n        return\n\n    for 选择 in 选择列表:\n        做选择\n        backtrack(路径, 选择列表)\n        撤销选择\n}\n```",
      "data": {
        "title": "回溯算法1--全排列",
        "date": "2020-06-18 18:41:07",
        "tags": [],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "hui-su-suan-fa-1-quan-pai-lie"
    },
    {
      "content": "> 决策过程\n```\n// base case\ndp[0][0]... = base\n    // 状态转移过程\n    for(状态1 in 状态1所有值) {\n        for (状态2 in 状态2所有值) {\n            ...\n            dp[状态1][状态2]... = 最值(选择1， 选择2， ...)\n        }\n    }\n```\n\n1. 自顶向下分析\n   ``` javascript\n   /**\n     * @description 自顶向下分析\n     * @param {*} coins \n     * @param {*} amount \n     */\n\n    const coinChange = (coins, amount) => {\n    const memo = []\n    function dp(n) {\n        if (memo[n]) return memo[n]\n        if (n === 0) return 0\n        if (n < 0) return -1\n        let res = amount + 1\n        for (let coin in coins) {\n            // 获得子问题\n        const sub = dp(n - coins[coin])\n        if (sub === -1) continue\n        res = min(res, 1 + sub)\n        }\n        memo[n] = res\n        return res !== amount + 1 ? memo[n] : -1\n    }\n    return dp(amount)\n    }\n\n    console.log('----', coinChange(arr, 11))\n\n   ```\n2.  自底向上分析\n   ``` javascript\n   var coinChange = function(coins, amount) {\n    const min = (a, b) => a > b ? b : a\n    const dp = new Array(amount + 1).fill(amount + 1)\n    // define init value\n    dp[0] = 0\n    // 状态转移\n    for(let i = 0; i< dp.length; i++) {\n        for(let coin in coins) {\n            if (i - coins[coin]) continue\n            dp[i] = min(dp[i], 1 + dp[i - coins[coin]])\n        }\n    }\n    return (dp[amount] === amount + 1) ? -1 : dp[amount]\n    };\n   ```",
      "data": {
        "title": "动态规划2---凑零钱",
        "date": "2020-06-18 18:18:18",
        "tags": [],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "dong-tai-gui-hua-2-cou-ling-qian"
    },
    {
      "content": "> 核心问题是枚举\n> 寻找最优子结构\n> 获得状态转移方程\n\n1. 直接使用递归操作\n   ``` javascript\n   const fib = n => {\n        if (n === 1 || n === 2) return 1\n        return fib(n - 1) + fib(n - 2)\n    }\n\n    console.log('---FIB___1---', fib(8))\n   ```\n2. 增加一个备忘录记录已经计算的值，避免重复计算（自顶向下）\n   ``` javascript\n   /**\n     * @desc 给斐波那契数列增加一个中间数组保存已经计算过的元素，\n     * @param {中间数组} memo \n     * @param {数列长度} n \n     */\n    const enhancer = (memo, n) => {\n        if (n === 1 || n === 2) return 1\n        if (memo[n]) return memo[n]\n        return enhancer(memo, n - 1) + enhancer(memo, n - 2)\n    }\n\n    const fib2 = n => {\n        const memo = []\n        return enhancer(memo, n)\n    }\n\n    console.log('----FIB___2----', fib2(8))\n   ```\n3. 使用自底向上的计算方式，将问题分解，获得最优子结构\n   ``` javascript\n   /**\n     * @desc 使用DP table\n     * @param {*} n \n     */\n    const fib3 = n => {\n    const dp = []\n    dp[0] = 0 \n    dp[1] = dp[2] = 1\n    for (let i = 3; i <= n; i++) {\n        dp[i] = dp[i - 1] + dp[i - 2]\n    }\n    return dp[n]\n    }\n\n    console.log('----FIB___3----', fib3(8))\n   ```\n4. 优化3，将dptable大小压缩\n   ``` javascript\n   /**\n     * @desc 因为数列的值只和之前的两个状态有关系，在这里保存之前的状态能够节省空间\n     * @description 【状态压缩】 将dp-table的大小压缩\n     * @param {*} n \n     */\n    const fib4 = n => {\n    if (n === 1 || n === 2) return 1\n    let prev = 1\n    let curr = 1\n    for (let i = 3; i <= n; i++) {\n        const sum = prev + curr\n        prev = curr\n        curr = sum\n    }\n    return curr\n    }\n\n    console.log('----FIB___4----', fib4(8))\n   ```",
      "data": {
        "title": "动态规划---1（斐波那契数列说起）·",
        "date": "2020-06-17 17:47:18",
        "tags": [],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "dong-tai-gui-hua-1fei-bo-na-qi-shu-lie-shuo-qi"
    },
    {
      "content": "\n### 关于非受控组件在异步操作中变更defaultValue信息的解决方案\n>> 可以增加一个key值\n\n\n### 正则:\n>> 手机号：`/^1(?:3\\d|4[4-9]|5[0-35-9]|6[67]|7[013-8]|8\\d|9\\d)\\d{8}$/`\n\n> fontSize会导致div所占实际区块变大（在inspector中无法找到，但是实际中是会覆盖掉其他div）\n\n\n\n### 代码执行顺序：\n> `macrotasks: setTimeout, setInterval, setImmediate, I/O, UI rendering`\n\n> `microtasks: process.nextTick, Promises, Object.observe(废弃), MutationObserver`\n\n\n> 同步代码——>microTask——>macroTask\n>> eg: `https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/`\n\n> iOS问题   \n>> `text-decoration-line: line-through;` -> `text-decoration: line-through;`\n\n\n### 列表中的两种组件，排版出错\n>> `vertical-align: top;`\n\n### React-Router\n\n> 嵌套路由中次级路由无法生效， 确认一级路由与次级路由的衔接是否使用了`exact={true}`\n\n\n### 页面中的请求数据处理\n\n> 1. 判断是否需要这个请求的条件，如果某个条件不满足，则不会去请求，如果满足发起请求\n> 2. 返回数据校验，防止数据出现`undefined`和`{}`, 的时候页面出现`TypeError`\n> 3. 组件处理: 不满足条件的时候禁止渲染该组件\n\n**解决方法**\n\n> 在最外层使用统一的数据处理方法，确保进入组件中的数据是自己想要的，同时在最外层的处理方法中对数据的可用性进行兜底判别，如果是`null` || `undefined`，进行兜底处理，返回一个空对象`{}`,否则对数据进行处理\n\n### `function`参数的边界值处理\n\n> 对于函数传递的参数，在函数内部一定要进行处理，边界值`0`, `null`, `undefined`等，防止极端情况下出错\n\n### iOS下fixed失效问题\n\n> iOS上面使用`fixed`布局在唤起键盘的时候`fixed`布局的组件会失效。\n> 解决方法： 对外层`div`设置\n```\nposition: absolute;\nwidth: 100%;\nleft: 0;\nright: 0;\ntop: 0;\nbottom: 0;\nfont-size: 0;\noverflow-y: scroll;\n-webkit-overflow-scrolling: touch;/* 解决ios滑动不流畅问题 */\n```\n> 让元素在内层`div`中滚动(不采用这种方式，页面是在`body`中滚动)\n\n### canvas 失真\n\n> 原因： 多发生在手机端，因为像素密度不一致导致失真\n\n```\nconst getPixelRatio = function(context) {\n    const backingStore = context.backingStorePixelRatio ||\n        context.webkitBackingStorePixelRatio ||\n        context.mozBackingStorePixelRatio ||\n        context.msBackingStorePixelRatio ||\n        context.oBackingStorePixelRatio || 1;\n\n    return (window.devicePixelRatio || 1) / backingStore;\n};\n```\n\n### ReactDOM -> findDOMNode\n\n> `findDOMNode(this).ownerDocument` 获取当前节点的HTML根节点\n\n\n###　js数组（new Array）是稀疏数组，无法map\n\n> `Array.apply(null, Array(n)).map(() => null)` // 初始化一个长度为N的数组并且赋值为null\n\n**apply** 会将生成的稀疏数组展开并传给上面`Array`构造函数\n\n```\nArray(n) === [,,...,,]; // 只有长度\nArray(null, ... , null)\n```\n\n> 上面的构造等于`new Array(n).fill(null)`\n\n### `React.PureComponent`和`this.forceUpdate()`\n\n> `React.PureComponent` 的 `shouldComponentUpdate()` 只会对对象进行浅对比。如果对象包含复杂的数据结构，它可能会因深层的数据不一致而产生错误的否定判断(表现为对象深层的数据已改变视图却没有更新)。当你期望只拥有简单的`props`和`state`时，才去继承 `PureComponent` ，或者在你知道深层的数据结构已经发生改变时使用 `forceUpate()` 。或者，考虑使用 不可变对象 来促进嵌套数据的快速比较！\n\n\n### `Windows` `git`大小写不敏感\n\n> `git config core.ignorecase false`\n### 关于结构赋值与`null`的问题\n``` javascript\n\nconst obj = {\n    a: null,\n    b: undefined,\n}\n\nconst {\n    a = [], b = {}\n} = obj;\nconsole.log(a, b);\n```\n> `node-sass`安装问题\n\n>> 需要安装`python`和`c++`编译环境\n>> `npm install --global --production windows-build-tools`\n\n### 滚动条\n\n> \n``` css\ndiv::-webkit-scrollbar {\n  /* 这里的宽是指竖向滚动条的宽，高是指横向滚动条的高*/      \n  width: 16px;      \n  height: 16px;      \n  background: pink;    \n}\ndiv::-webkit-scrollbar-thumb {      \n  border-radius: 10px;      \n  background: \n  linear-gradient(red,orange);    \n}\n```\n\n> 使用“&&”运算符的时候，如果两边的操作数有一个不是布尔类型，那么返回值不一定是布尔类型\n  1. 有一个是`null`， 则返回`null`\n  2. 有一个是`undefined`，则返回`undefined`\n  3. 第一个是对象，则返回第二个，为true，则返回第二个，为false，则返回false  \n\n> offsetWidth/offsetHeight\n>> CSS width 属性值 + 左右 padding + 左右 border + 垂直滚动条宽度 = offsetWidth\n>> CSS height 属性值 + 上下 padding + 上下 border + 水平滚动条高度 = offsetHeight\n\n** 这里列出需要关注的重点：**\n\n> * offsetWidth/offsetHeight 是只读属性，手动赋值虽不会报错，但也不会生效。所以，也就不能通过这两个属性动态的修改元素的宽高。\n> * offsetWidth/offsetHeight 返回值总是整数，而不是精确的浮点数，四舍五入取整数。\n若元素 display: none，那么 offsetWidth/offsetHeight 为 0。\n> * offsetHeight 的值不包括伪元素的高度，例如 :before 和 :after。\n若元素内部包含未清除浮动的子元素，那么将不包含这些浮动元素的宽高。\n\n\n# React区分组件类型\n> React的组件可以分为`ClassComponent`、`FunctionComponent`\n> `ClassComponent`对应的`Element type`是`当前Class`自身，`FunctionComponent`对应的`Element type`是函数组件自身\n\n``` javascript\nAppClass instanceof Function === true\nAppFunc instanceOf === true\n```\n> 通过引用类型是无法区分当前组件的`type`的\n> 可以通过调用`ClassComponent`原型链的`isReactComponent`属性判断是否是`classComponent`\n\n``` javascript\nClassComponent.prototype.isReactComponent = {}\n```",
      "data": {
        "title": "一些问题",
        "date": "2020-05-22 18:13:19",
        "tags": [
          "一些问题"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "yi-xie-wen-ti"
    },
    {
      "content": "1. helmet express 安全性\n2. express-rate-limit express 速率限制器（限制ip访问）\n3. csurf 防止CSRF跨站脚本攻击\n\n包压缩\n1. http开启gzip\n2. compression 对响应进行压缩",
      "data": {
        "title": "npm-nest",
        "date": "2020-05-14 18:19:22",
        "tags": [],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "npm-nest"
    },
    {
      "content": "<!--以Android为例-->\n\n# `WebView`\n## 在`Android`中的定义\n* `BPWebBridge`: 定义方法\n    > 暴露给`bridge`的方法\n    > 定义`handler`在子线程调用完成之后，触发`UI`线程的渲染\n* `BPWebUIRouter`: 定义调用模块\n    > 设置前端调用的命令字以及前端调用原生的业务逻辑\n    > 定义参数类型\n\n## 在前端的定义\n* 从前端全局暴露的`WebViewJavascriptBridge`属性入手，这个属性中包含了四个对象：\n  ``` javascript\n  window.WebViewJavascriptBridge = {\n        callHandler: callHandler,\n        hasHandler: hasHandler,// 可删除\n        // ——new api——————————————————————————————————————————\n        registerHandler: registerHandler,\n        hasRegisteredHandler: hasRegisteredHandler\n        // ————————————————————————————————————————————————\n    };\n  ```\n\n  参照客户端代码和前端的一些定义方法\n  ``` java\n  @JavascriptInterface\n    public boolean hasHandler(final String cmd) {\n        // todo\n    }\n\n    @JavascriptInterface\n    public void send(final String cmd, String data, final String callback) {\n        // todo\n    }\n  ```\n  可以看到客户端通过注解（`JavascriptInterface`）将`send`和`hasHandler`方法与前端进行了关联，这个时候前端通过调用`hasHandler`实际上是走到了原生的调用方法，前端的定义是无效的。\n  也就是说通过`window.WebViewJavascriptBridge.xxx`的方式向外部暴露的属性全部都是在前端所定义的。\n* 接下来分析一下看一下`window.bridge`中定义的方法\n``` java \nprivate static final String BRIDGE_RESULT_BACK_TEMPLATE =\n            \"javascript: window.bridge.onReceive(\\'%1$s\\', \\'%2$s\\');\";\n\nprivate static final String BRIDGE_CALL_TEMPLATE =\n            \"javascript: window.bridge.call(\\'%1$s\\', \\'%2$s\\', \\'%3$s\\');\";\n\n```\n可以看到`onRecieve`和`call`方法是通过客户端内部封装的方法注入到`js`里面的，同时定义了传入的参数个数\n\n## `callHandler`调用过程\n\n![](/post-images/1570613811174.png)\n上面的图展示了从前端到客户端的调用过程，\n* 前端通过`callHandler`方法调用了`window.bridge.send`方法<FE>\n* `window.bridge.send`通过触发`BPWebUIRouter.handleCmd`触发命令字的调用<BPWebBridge>\n* `BPWebUIRouter.handleCmd`方法调用示例`showToast(bridge, data, callback);`可以看出来实际上传入的是一个`bridge`,而这个`bridge`就是上文中的`BPWebViewBridge`\n``` java\nprivate static void showToast(BPWebBridge bridge, JSONObject data, String callback) {\n        String msg = data.optString(KEY_MSG, \"\");\n        if (TextUtils.isEmpty(msg)) {\n            return;\n        }\n        BBToastManager.getInstance().show(msg);\n        bridge.sendResultBack(callback, new BPBaseWebResult(RESULT_CODE.RESULT_SUCCESS));\n    }\n```\n* 以`showToast`方法的调用为示例进行分析，可以看到在`BPWebUIRouter`中最终的调用还是到了`BPWebviewBridge`中，最终调用的方法就是`sendResultBack`\n* 在`sendResultBack`中通过`webview.loadUrl`进行了拦截\n``` java\npublic void sendResultBack(final String callback, final BPBaseWebResult result) {\n        Handler webViewHandler = webView.getHandler();\n        if (webViewHandler != null) {\n            webViewHandler.post(() -> {\n                String js =\n                        String.format(BRIDGE_RESULT_BACK_TEMPLATE, callback, result.toDataString());\n                BBAppLogger.i(\"send result back: %1$s\", js);\n                webView.loadUrl(js);\n            });\n        }\n    }\n```\n通过上文可以知道`BRIDGE_RESULT_BACK_TEMPLATE`是一个注入的对象--->`window.bridge.onReceive`,接下来回到`onReceive`方法，看看它做了什么\n* 在`onReceive`中主要通过是否传递`callbackId`，来判断是`js`调用客户端，或者是客户端调用`js`\n``` javascript\nwindow.bridge.onReceive = function (callbackId, result) {\n\t\t\tvar resultObj = {};\n\t\t\ttry {\n\t\t\t\tresultObj = JSON.parse(result);\n\t\t\t} catch (ex) {}\n\n\t\t\t/**\n\t\t\t * 1，如果是客户端的回调，会带上 callbackId\n\t\t\t * 2，如果是客户端的主动调用，callbackId传''空串，resultObj会存在handlerName标识，由JS来处理handler的调用\n\t\t\t */\n\t\t\tif (callbackId) {\n\t\t\t\tcallbacks[callbackId](resultObj);\n\t\t\t\tdelete callbacks[callbackId];\n\t\t\t} else if (resultObj.handlerName) {\n\t\t\t\tvar handler = messageHandlers[resultObj.handlerName];\n\t\t\t\tif (typeof handler === 'undefined') return;\n\n\t\t\t\tfor (var i = 0; i < handler.length; i++) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tdelete resultObj.handlerName;\n\t\t\t\t\t\thandler[i](resultObj);\n\t\t\t\t\t} catch (exception) {\n\t\t\t\t\t\tif (typeof console != 'undefined') {\n\t\t\t\t\t\t\tconsole.log(\"WebViewJavascriptBridge: WARNING: javascript handler threw.\", resultObj, exception);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n```\n## `regristerHandler` 调用流程\n<!--以onSelectContact为例-->\n* 先给出调用示例图\n![](/post-images/1570620158840.png)\n可以看出一共涉及了三个流程：\n* 在客户端中注册`EventBus`\n``` java\n  EventBus.getInstance().register(EventConst.MERCHANT_OAUTH.OAUTH_VERIFY, mOnOAuthVerifiedResult);\n```\n* 在前端注册一个方法\n``` java\nonSelectContact: registerHandlerWrapper('onSelectContact'),\n```\n* `EventBus`去监听这个方法\n``` java\nregisterActivityForResultCallback(BPNavigationHelper.REQUEST_CHOOSE_CONTACT, (resultCode, data) -> {\n            if (resultCode == RESULT_OK) {\n                String number = data.getStringExtra(\n                        BPPickPhoneContactView.KEY_CONTACT_NUMBER);\n                String name = data.getStringExtra(BPPickPhoneContactView.KEY_CONTACT_NAME);\n                mBridge.callHandler(new BPGetContactsInfoWebCall(BPWebUIRouter.RESULT_CODE.RESULT_SUCCESS, BPWebUIRouter.CALL_H5_HANDLE_NAME.HANDLER_NAME_ON_SELECT_CONTACTS, name, number).toDataString());\n```\n* 调用`BPWebBridge``callHandler`\n``` java\npublic void callHandler(String data) {\n        Handler webViewHandler = webView.getHandler();\n        if (webViewHandler != null) {\n            webViewHandler.post(() -> {\n                String js =\n                        String.format(BRIDGE_RESULT_BACK_TEMPLATE, \"\", data);\n                BBAppLogger.i(\"send result back: %1$s\", js);\n                webView.loadUrl(js);\n            });\n        }\n    }\n```\n* 后续的调用（`oReceive`）,看上面的代码\n\n",
      "data": {
        "title": "JSBridge",
        "date": "2019-09-29 12:06:38",
        "tags": [],
        "published": false,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "jsbridge"
    },
    {
      "content": "<!--以React为示例-->\n# 前端埋点问题\n\n## 曝光\n* 场景分布\n    > 页面中的元素出现在当前的视窗之中\n\n* 实现思路\n>  * 针对于SPA页面的特性，对于页面的整体曝光（单个路由的PV）\n``` javascript\ncomponentDidMount() {\n    Logger.trackingRecord(TRACKING.PV);\n}\n```\n> * 对于页面中某个元素的曝光\n    1. 在这个场景中，我们可以对页面中的曝光逻辑进行拆分![](https://qingwu-aby.github.io//post-images/1569726066873.png)\n        如上图所示，在这个场景中需要曝光的元素在一个视口中能够全部展示出来，我们可以在一个组件中将这个元素的所有埋点全部曝光出来\n        <!-- 凑个字数 -->\n``` javascript\n    renderHeader() {\n        <Impr trackingInfo={TRACKING.HEADER}>\n            <div className='header'>Header</div>\n        </Impr>\n    }\n    renderContent() {\n        <Impr trackingInfo={TRACKING.CONTENT}>\n            <div className='content'>Content</div>\n        </Impr>\n    }   \n    renderButton() {\n        <Impr trackingInfo={TRACKING.BUTTON}>\n            <div className='button'>Button</div>\n        </Impr>\n    }\n    render() {\n        return (\n            <React.Fragment>\n        {\n            renderHeader()\n            renderContent()\n            renderButton()\n        }\n        <React.Fragemnt>\n        )\n    }\n```\n``` javascript\nclass Impr extends React.Component {\n    comsponentDidMount() {\n        Logger.trackingRecord(this.props.imprTracking)\n    }\n    render() {\n        return this.props.children;\n    }\n}\n```\n        这是一个最简单的场景应用，如果页面上有大量的元素存在，并且相当一部分不在当前的视口中的时候，这种做法会对曝光的数据带来不可控（你不知道元素是否已经被用户看到了）。\n    2. 这个时候就可以引入新的方式`Intersection-observe`：\n        因为可见性的本质是目标元素与当前视口出现的交叉区域。文档[IntersectionOberver](https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API)\n        ![](https://qingwu-aby.github.io//post-images/1569744502847.jpg)\n        如图所示我们只需要上报已经出现在视口中的元素就可以了，下方不在当前视口中的元素将不会曝光，每个元素在都会被observe，在监听事件结束之后将会销毁确保曝光逻辑只会出现一次\n``` javascript\nclass Impr extends React.Component {\n    registeryImprComponent() {\n        new IntersectionObserver(this.callback, params)\n    }\n    callback() {\n        // 设置交叉阈值（触发打点上报逻辑） 以及曝光时间\n    }\n}\n```\n    3. 当然也可以监听`scroll`事件，通过计算目标元素`element.getBoundingClientRect()`获取元素与容器之间的距离，但是这种情况会频繁触发`scroll`导致严重的性能问题  \n\n## 点击\n* 场景分布\n    > * 点击某个元素\n    > * 触发原生操作\n\n* 实现思路\n> * 元素点击\n    1. 点击事件\n        * 通过侵入型事件来触发上报操作\n  ``` javascript\n  jumpToNext() {\n      // 其他逻辑\n      Logger.trackingRecord(TRACKING.CLICK)\n  }\n  ```\n\n        * 通过方法装饰器来触发\n\n``` javascript\n    @Logger.trackingRecord(TRACKING.CLICK)\n    jumpToNext() {\n        // 其他    \n    }\n```\n    1. 监听原生返回\n        * 装饰器触发\n        * 设置`BaseComponet`，组件通过继承父类的方法或者通过实现的方式来完成上报操作\n\n``` javascript\nclass BaseComponent extends React.Component {\n    componentDidMount() {\n        this.props.history.listen((location, action) => {\n            //action === POP\n            // Logger.trackingRecord(this.getBaseParams());\n        })\n    }\n    getBaseParams() {\n        // 方法在这定义\n    }\n}\nclass Page extends BaseComponent {\n    componentDidMount() {\n        super.componentDidMount()\n        // todo\n    }\n    getBaseParams() {\n        // you can set trackingParams\n    }\n}\n```\n\n## visibility\n> 场景分布\n\n    > 应用中视窗元素被隐藏（后台运行）",
      "data": {
        "title": "曝光和点击",
        "date": "2019-09-23 11:04:37",
        "tags": [
          "埋点"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "tracking"
    }
  ],
  "tags": [
    {
      "name": "React",
      "slug": "Bo2MqkwLq",
      "used": true
    },
    {
      "name": "JS基础",
      "slug": "WHkzkmUVJ",
      "used": true
    },
    {
      "index": -1,
      "name": "算法和数据结构",
      "slug": "HDG5upSe4",
      "used": true
    },
    {
      "name": "todo",
      "slug": "o-FN4Uam8n",
      "used": true
    },
    {
      "index": 0,
      "name": "埋点",
      "slug": "iheqDLI6k",
      "used": true
    },
    {
      "index": -1,
      "name": "一些问题",
      "slug": "H8FJNbNzO",
      "used": true
    },
    {
      "index": -1,
      "name": "nestJs",
      "slug": "ulLDOo7JD",
      "used": false
    },
    {
      "index": -1,
      "name": "数据上报",
      "slug": "ECkt7EOIF",
      "used": false
    }
  ],
  "menus": [
    {
      "link": "/",
      "name": "首页",
      "openType": "Internal"
    },
    {
      "link": "/archives",
      "name": "归档",
      "openType": "Internal"
    },
    {
      "link": "/tags",
      "name": "标签",
      "openType": "Internal"
    },
    {
      "link": "/post/about",
      "name": "关于",
      "openType": "Internal"
    }
  ]
}